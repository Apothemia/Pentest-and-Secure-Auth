# %% Imports
from __future__ import annotations
import sys

if sys.version_info.major != 3:
    raise SystemExit('!!> Python version must be 3.X.X (preferably, 3.9.X)')
elif sys.version_info.minor != 9:
    print('??> This script was tested with Python version 3.9.X, '
          'using it with any other version may produce unexpected results.\n'
          '??> Do you still want to continue? (Y/N)')
    user_input = input('>>> ')
    if user_input == 'Y':
        pass
    elif user_input == 'N':
        print('>>> Terminating...')
        exit(0)
    else:
        raise SystemExit('!!> Invalid input')

from time import sleep
from importlib.util import find_spec

import subprocess
if find_spec('scapy') is None:
    subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'scapy', '--disable-pip-version-check'])

from scapy.sendrecv import sr, sr1
from scapy.layers.inet import IP, ICMP, TCP
from scapy.volatile import RandShort

import dataclasses
import logging
import itertools


# %% TaskInfo Class
@dataclasses.dataclass
class TaskInfo:
    name: str
    func: object
    desc: str
    required_args: list = None
    optional_args: list = None

    def info(self):
        print()
        print(f'[{self.name}]')
        print(f'[Description]\n'
              f'   {self.desc}')
        if self.required_args is not None:
            print('[Usage]\n'
                  '  ' + ' '.join(self.required_args), end='')
        if self.optional_args is not None:
            print(' [ optional_args ]\n' + ' '*4 + 'optional_args: ' + ' '.join(self.optional_args))
        else:
            print('')


# %% PenTest Class
class PenTest:

    def __init__(self):
        self.icmp_file_path = 'icmp.dat'
        self.tasks = {
            '0': TaskInfo(name='ICMP Ping', func=self.icmp_ping,
                          desc='Pings an IP range and collects IP addresses of the hosts that are alive.',
                          required_args=['destination_ip'],
                          optional_args=['range_one', 'range_two', 'range_three', 'range_four']),
            '1': TaskInfo(name='Port Identification', func=self.port_identification,
                          desc='Performs a port scan on the hosts that are alive.'),
            '2': TaskInfo(name='OS Fingerprint Identification', func=self.os_fingerprint_identification,
                          desc=''),  # TODO: Specify arguments and description
            '3': TaskInfo(name='Web Server Detection', func=self.web_server_detection,
                          desc=''),  # TODO: Specify arguments and description
            '4': TaskInfo(name='SYN Flood', func=self.syn_flood,
                          desc=''),  # TODO: Specify arguments and description
            '5': TaskInfo(name='Show Files', func=self.show,
                          desc=''),  # TODO: Specify arguments and description
            'X': TaskInfo(name='Exit', func=exit,
                          desc='Terminates the program.')
        }

    @staticmethod
    def start():
        logging.getLogger("scapy.runtime").setLevel(logging.ERROR)  # TODO: Disable this while debugging
        instance = PenTest()
        while True:
            instance.show_menu()
            try:
                mode_id = input('>>> ')
                selected_task = instance.tasks[mode_id]
                selected_task.info()
                instance.tasks[mode_id].func()
            except KeyboardInterrupt:
                break
            break

    def show_menu(self):
        for option_id, option in self.tasks.items():
            print(f'  [{option_id}] {option.name}')

    def icmp_ping(self):
        """
        Ping an IP range and collect IP addresses of the hosts that are alive and save the result in icmp.dat.
        """
        # Input validation
        try:
            raw_input = input('>>> ')
        except KeyboardInterrupt:
            raise SystemExit('Terminating with KeyboardInterrupt...')
        except EOFError:
            raise SystemExit('Terminating with EOFError...')

        args = raw_input.split()

        try:
            dest_ip = args.pop(0)

            # Checking if the IP address has exactly 4 parts
            ip_parts = dest_ip.split('.')
            if len(ip_parts) != 4:
                raise SystemExit("!!> Invalid IP address.")

            # Checking if the parts of the IP address is between 0 and 255 or is a wildcard char (*)
            for ip_part in ip_parts:
                if ip_part == '*':
                    continue
                if not 0 <= int(ip_part) <= 255:
                    raise SystemExit("!!> Parts of the IP address must be in range [0, 255]")

            # Checking if there are as many wildcard chars as the number of optional arguments
            if dest_ip.count('*') != len(args):
                raise SystemExit("!!> Number of *'s and the length of args do not match.")

            range_args = []
            for arg in args:
                parsed_arg_list = arg.split('-')
                if len(parsed_arg_list) == 1:
                    raise SystemExit("!!> Range argument cannot be a single value.")
                int_arg_list = list(map(int, parsed_arg_list))
                int_arg_list[1] += 1
                range_args.append(list(range(*int_arg_list)))

        except Exception as e:
            # Handling any other exception here
            raise SystemExit(e)

        # Combining multiple ranges
        range_combinations = list(itertools.product(*range_args))

        # Sending pings to a range of IPs
        alive_host_ips = []
        for ip_args in range_combinations:
            dest_ip_literal = dest_ip
            for ip_arg in ip_args:
                dest_ip_literal = dest_ip_literal.replace('*', str(ip_arg), 1)
            ans = sr1(IP(dst=dest_ip_literal) / ICMP(), timeout=2, verbose=False)
            if ans is not None:
                alive_host_ips.append(ans.src)
            sleep(0.25)

        with open(self.icmp_file_path, mode='w', encoding='utf8') as output_file:
            output_file.write(';'.join(alive_host_ips))

    def port_identification(self):
        """
        1) Get the IP addresses from the icmp.dat file and scan and validate these IP addresses.
        If an IP address is a valid live host address append it to a string or list (live hosts) that will contain the
        IP addresses of the live hosts. A live host is an active host that can be monitored by nmap or Wireshark.

        2) Now perform port scan on the live hosts. The scanning must find and identify ports on each host and save the
        results in openPorts.dat. This text file will contain Host IPs, ports numbers, and service/application names
        (if any) of each port.
        """
        with open(self.icmp_file_path, mode='r', encoding='utf8') as input_file:
            ip_addresses = input_file.read().split(';')

        alive_host_ips = []
        for ip_address in ip_addresses:
            ans = sr1(IP(dst=ip_address) / ICMP(), timeout=2, verbose=False)
            if ans is not None:
                alive_host_ips.append(ans.src)
            sleep(0.5)

        print('[Live Hosts]\n   ' + '\n   '.join(alive_host_ips) + '\n')

        # Some code I found online LULE
        dest_ip = alive_host_ips[0]  # For testing
        src_port = RandShort()
        dest_port = 80

        ans = sr1(IP(dst=dest_ip)/TCP(sport=src_port, dport=dest_port, flags='S'), timeout=5)

        if ans is None:
            raise SystemExit(f'\n??> {dest_ip}:{dest_port} refused to establish connection.\n')
        elif ans.haslayer(TCP):
            if ans.getlayer(TCP).flags == 0x12:
                send_rst = sr(IP(dst=dest_ip)/TCP(sport=src_port, dport=dest_port, flags='AR'), timeout=5)
                print('??> Established TCP connection.')
            elif ans.getlayer(TCP).flags == 0x14:
                print('>>? Refused TCP connection.')

    def os_fingerprint_identification(self):
        """
        This function will get the host IPs from the text file (openPorts.dat) and identify operating systems (OS) and
        OS versions of the hosts.
        """

    def web_server_detection(self):
        """
        Scan the Internet and discover 10 web-server addresses, protocols, and ports of each web server.
        Save the results in web.dat.
        """

    def syn_flood(self):
        """
        This function will launch SYN-flood attack to a given destination (IP) and port(s).
        This tool must also enable you to choose the number of flooding, e.g., 10.000 SYN attacks.
        While running the SYN-flood attack use some Python codes to capture and decode TCP and IP packet headers and
        save them in SYNresults.txt. If you want, you can also use Wireshark or tcpdump to capture the attack packets
        and save the packets to a pcap file. Thereafter, use a Python code to decode and save the results.
        """

    def show(self):
        """
        This function will ask and display the contents of the files that your tools have created so far.
        """


# %% Main

if __name__ == '__main__':
    PenTest.start()
