# %% Imports
from __future__ import annotations
import sys
import subprocess as sp
import re

if sys.version_info.major != 3:
    raise SystemExit('!!> Python version must be 3.X.X (preferably, 3.9.X)')
elif sys.version_info.minor != 9:
    print('??> This script was tested with Python version 3.9.X, '
          'using it with any other version may produce unexpected results.\n'
          '??> Do you still want to continue? (Y/N)')
    user_input = input('>>> ')
    if user_input == 'Y':
        pass
    elif user_input == 'N':
        print('>>> Terminating...')
        exit(0)
    else:
        raise SystemExit('!!> Invalid input')

from time import sleep
from importlib.util import find_spec

import subprocess

if find_spec('scapy') is None:
    subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'scapy', '--disable-pip-version-check'])

from scapy.all import *  
from scapy.sendrecv import sr, sr1
from scapy.layers.inet import IP, ICMP, TCP
from scapy.volatile import RandShort

import dataclasses
import logging
import itertools


# %% TaskInfo Class
@dataclasses.dataclass
class TaskInfo:
    name: str
    func: object
    desc: str
    required_args: list = None  
    optional_args: list = None  

    def info(self):
        print()
        print(f'[{self.name}]')
        print(f'[Description]\n'
              f'   {self.desc}')
        if self.required_args is not None:
            print('[Usage]\n'
                  '  ' + ' '.join(self.required_args), end='')
        if self.optional_args is not None:
            print(' [ optional_args ]\n' + ' ' * 4 + 'optional_args: ' + ' '.join(self.optional_args))
        else:
            print('')


# %% PenTest Class
class PenTest:

    def __init__(self):
        self.icmp_file_path = 'icmp.dat'
        self.open_ports_file_path = 'openPorts.dat'
        self.web_server_ports_file_path = 'web.dat'
        self.tasks = {
            '0': TaskInfo(name='ICMP Ping', func=self.icmp_ping,
                          desc='Pings an IP range and collects IP addresses of the hosts that are alive.',
                          required_args=['destination_ip'],
                          optional_args=['range_one', 'range_two', 'range_three', 'range_four']),
            '1': TaskInfo(name='Port Identification', func=self.port_identification,
                          desc='Performs a port scan on the hosts that are alive.'),
            '2': TaskInfo(name='OS Fingerprint Identification', func=self.os_fingerprint_identification,
                          desc='Identifies the OS of the hosts that are alive.'),
            '3': TaskInfo(name='Web Server Detection', func=self.web_server_detection,
                          desc='Performs a scan on the internet to detect 10 web servers.',
                          required_args=['destination_ip']),
            '4': TaskInfo(name='SYN Flood', func=self.syn_flood,
                          desc=''),  # TODO: Specify arguments and description
            '5': TaskInfo(name='Show Files', func=self.show,
                          desc=''),  # TODO: Specify arguments and description
            'X': TaskInfo(name='Exit', func=exit,
                          desc='Terminates the program.')
        }

    @staticmethod
    def start():
        logging.getLogger("scapy.runtime").setLevel(logging.ERROR)  # TODO: Disable this while debugging
        instance = PenTest()
        while True:
            instance.show_menu()
            try:
                mode_id = input('>>> ')
                selected_task = instance.tasks[mode_id]
                selected_task.info()
                instance.tasks[mode_id].func()  
            except KeyboardInterrupt:
                break
            break

    def show_menu(self):
        for option_id, option in self.tasks.items():
            print(f'  [{option_id}] {option.name}')

    def icmp_ping(self):
        """
        Ping an IP range and collect IP addresses of the hosts that are alive and save the result in icmp.dat.
        """
        # Input validation
        try:
            raw_input = input('>>> ')
        except KeyboardInterrupt:
            raise SystemExit('>>> Terminating with KeyboardInterrupt...')
        except EOFError:
            raise SystemExit('>>> Terminating with EOFError...')

        args = raw_input.split()

        try:
            dest_ip = args.pop(0)

            # Checking if the IP address has exactly 4 parts
            ip_parts = dest_ip.split('.')
            if len(ip_parts) != 4:
                raise SystemExit("!!> Invalid IP address.")

            # Checking if the parts of the IP address is between 0 and 255 or is a wildcard char (*)
            for ip_part in ip_parts:
                if ip_part == '*':
                    continue
                if not 0 <= int(ip_part) <= 255:
                    raise SystemExit("!!> Parts of the IP address must be in range [0, 255]")

            # Checking if there are as many wildcard chars as the number of optional arguments
            if dest_ip.count('*') != len(args):
                raise SystemExit("!!> Number of *'s and the length of args do not match.")

            range_args = []
            for arg in args:
                parsed_arg_list = arg.split('-')
                if len(parsed_arg_list) == 1:
                    raise SystemExit("!!> Range argument cannot be a single value.")
                int_arg_list = list(map(int, parsed_arg_list))
                int_arg_list[1] += 1
                range_args.append(list(range(*int_arg_list)))

        except Exception as e:
            # Handling any other exception here
            raise SystemExit(e)

        # Combining multiple ranges
        range_combinations = list(itertools.product(*range_args))

        # Sending pings to a range of IPs
        alive_host_ips = []
        for ip_args in range_combinations:
            dest_ip_literal = dest_ip
            for ip_arg in ip_args:
                dest_ip_literal = dest_ip_literal.replace('*', str(ip_arg), 1)
            ans = sr1(IP(dst=dest_ip_literal) / ICMP(), timeout=2, verbose=False)
            if ans is not None:
                alive_host_ips.append(ans.src)
                print(ans.src, ' +')
            else:
                print(dest_ip_literal)
            # sleep(0.01)

        with open(self.icmp_file_path, mode='w', encoding='utf8') as output_file:
            output_file.write(';'.join(alive_host_ips))

    def port_identification(self):
        """
        1) Get the IP addresses from the icmp.dat file and scan and validate these IP addresses.
        If an IP address is a valid live host address append it to a string or list (live hosts) that will contain the
        IP addresses of the live hosts. A live host is an active host that can be monitored by nmap or Wireshark.

        2) Now perform port scan on the live hosts. The scanning must find and identify ports on each host and save the
        results in openPorts.dat. This text file will contain Host IPs, ports numbers, and service/application names
        (if any) of each port.
        """
        port_re = '[1-9][0-9]{0,5}\/[a-zA-Z]{1,5}'
        open_port_re = '[1-9][0-9]{0,5}\/[a-zA-Z]{1,5}[\s]{1,5}open'
        open_ports = []
        
        with open(self.icmp_file_path, mode='r', encoding='utf8') as input_file:
            ip_addresses = input_file.read().split(';')

            alive_hosts = []
            for ip_address in ip_addresses:
                ip = sp.getoutput(f'nmap -Pn {ip_address}')
                if re.search("0 hosts up", ip):
                    continue
                alive_hosts.append([ip, ip_address])

            for alive_host in alive_hosts:
                alive_host_info = alive_host[0].split("\n")
                for i in alive_host_info:
                    if re.search(open_port_re, i):
                        lst = [i.split(" ")[0], i.split(" ")[-1], alive_host[-1].strip()]
                        port_and_protocol = lst[0].split("/")
                        lst.pop(0)
                        lst.insert(0, port_and_protocol[0])
                        lst.insert(1, port_and_protocol[1])
                        open_ports.append(":".join(lst))

            with open(self.open_ports_file_path, mode='w', encoding='utf8') as output_file:
                output_file.write(";".join(open_ports))
                
    def os_fingerprint_identification(self):
        """
        This function will get the host IPs from the text file (openPorts.dat) and identify operating systems (OS) and
        OS versions of the hosts.
        """
        os_versions = []
        ports = []
        ip_addresses = []
        with open(self.open_ports_file_path, mode='r', encoding='utf8') as input_file:
            ips_with_ports = input_file.read().split(';')

            for ip_with_port in ips_with_ports:
                ip, port = ip_with_port.split(':')[-1].strip(), int(ip_with_port.split(':')[0].strip())
                ports.append(port)
                ip_addresses.append(ip)

        for ip_address, port in zip(ip_addresses, ports):
            os_output = sp.getoutput(f'nmap -sS {ip_address} -O')
            
            if re.search("No exact OS matches for host", os_output):
                os_output = sp.getoutput(f'nmap -sS {ip_address} -O --osscan-guess')
                for line in os_output.split("\n"):
                    if line.startswith("Aggressive OS guesses: "):
                        os_versions = line[line.index(":")+2:].strip().split(",")
                        print(f'No exact OS found for {ip_address}:{port}. Here are some guesses:')
                        print('[OS Versions]\n    '+ '\n   '.join(os_versions) + '\n')
            elif re.search("No OS matches for host", os_output):
                print(f"No OS found for {ip_address}:{port}")
            else:
                for line in os_output.split("\n"):
                    if line.startswith("OS details: "):
                        print(f"{ip_address}: {line[line.index(':')+2:].strip()}")

    def web_server_detection(self):
        """
        Scan the Internet and discover 10 web-server addresses, protocols, and ports of each web server.
        Save the results in web.dat.
        """
        # 21: (ftp control), 22: (ssh)
        # 23: (telnet), 25: (smtp)
        # 80: (http), 115: (sftp)
        # 143: (imap), 443: (https)
        # 546: (dhcp client), 547: (dhcp server)
        ipv4_re = '[1-9][0-9]{0,2}\.[1-9][0-9]{0,2}\.[1-9][0-9]{0,2}\.[1-9][0-9]{0,2}' 

        try:
            raw_input = input('>>> ')
        except KeyboardInterrupt:
            raise SystemExit('>>> Terminating with KeyboardInterrupt...')
        except EOFError:
            raise SystemExit('>>> Terminating with EOFError...')
        
        web_servers = sp.getoutput(f'nmap -p 21,22,23,25,80,115,143,443,546,547 {raw_input}')
        server_ports = web_servers.split("\n")
        ports = []

        for line in server_ports:
            if line.startswith("Nmap scan report for"):
                ip_address = re.findall(f'{ipv4_re}', line)[0]
                ports = server_ports[server_ports.index(line)+4:server_ports.index(line)+14]
                print("[Open Ports]")
                for port in ports:
                    print("   ", port)

        with open(self.web_server_ports_file_path, mode="w", encoding="utf8") as output_file:
            output_file.write('\n'.join(ports))

    def syn_flood(self):
        """
        This function will launch SYN-flood attack to a given destination (IP) and port(s).
        This tool must also enable you to choose the number of flooding, e.g., 10.000 SYN attacks.
        While running the SYN-flood attack use some Python codes to capture and decode TCP and IP packet headers and
        save them in SYNresults.txt. If you want, you can also use Wireshark or tcpdump to capture the attack packets
        and save the packets to a pcap file. Thereafter, use a Python code to decode and save the results.
        """

    def show(self):
        """
        This function will ask and display the contents of the files that your tools have created so far.
        """


# %% Main

if __name__ == '__main__':
    PenTest.start()
    # src_ip = '192.168.189.91'
    # dest_ip = '192.168.128.251'

    # for port in range(2, 1024):
    #     ans = sr1(IP(dst=dest_ip) / TCP(dport=port, flags='S'), timeout=5)

    #     if ans is None:
    #         raise SystemExit(f'\n??> {dest_ip}:{port} refused to establish connection.\n')
    #     elif ans.haslayer(TCP):
    #         if ans.getlayer(TCP).flags == 0x12:
    #             send_rst = sr(IP(dst=dest_ip) / TCP(flags='AR'), timeout=5)
    #             print(f'??> Established TCP connection to {dest_ip}:{port}.')
    #             break
    #         elif ans.getlayer(TCP).flags == 0x14:
    #             print('>>? Refused TCP connection.')

    # ans, uans = sr(IP(dst=dest_ip) / ICMP(), timeout=2)
    # res.nsummary(lfilter=lambda s, r: (r.haslayer(TCP) and (r.getlayer(TCP).flags & 2)))

    # send(IP(dst=dest_ip) / TCP(flags="S", dport=(1, 6000)))
    # sniffed_packets = sniff(filter=f'(src net {dest_ip}) && (dst net {src_ip})', stop_filter=lambda x: x.haslayer(TCP))
    # sniffed_packets.show()
