import os
import sys
import subprocess
from importlib.util import find_spec

# if find_spec('numpy') is None:
#     subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'numpy', '--disable-pip-version-check'])
# import numpy as np

if find_spec('rsa') is None:
    subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'rsa', '--disable-pip-version-check'])
import rsa

from random import randint
from math import gcd, sqrt


class Crypto:

    @staticmethod
    def encrypt(message, key):
        return rsa.encrypt(message.encode(AuthService.message_encoding), key)

    @staticmethod
    def decrypt(ciphertext, key):
        return rsa.decrypt(ciphertext, key).decode(AuthService.message_encoding)

    @staticmethod
    def sign(message, key):
        return rsa.sign(message.encode(AuthService.message_encoding), key, AuthService.hashing_algorithm)

    @staticmethod
    def verify(message, signature, key):
        return rsa.verify(
            message.encode(AuthService.message_encoding), signature, key, ) == AuthService.hashing_algorithm


class Util:
    @staticmethod
    def print_prime_numbers(max_val):
        for number in range(2, max_val):
            if Util.is_prime(number):
                print(number)

    @staticmethod
    def print_prime_and_congruent_numbers(max_val):
        for number in range(2, max_val):
            if Util.is_prime(number) and Util.is_congruent_number(number):
                print(number)

    @staticmethod
    def is_prime(number):
        if number < 2:
            return False
        elif number == 2 or number == 3:
            return True
        elif number % 2 == 0:
            return False
    
        dx = 4
        for i in range(5, int(sqrt(number)), dx):
            if number % i == 0:
                if number / i == number // i:
                    print(f'{number}/{i} = {number/i}')
                    return False
                else:
                    raise SystemExit('Calculation error.')
            dx -= dx - 6
    
        return True

    @staticmethod
    def is_congruent_number(number):
        # a - b = k * n
        # b = 3
        # k = 4
        # number - 3 = 4 * n
        if (number - 3) % 4 == 0:
            return True
        else:
            return False

    @staticmethod
    def find_x(p, q):
        if Util.is_prime(p) and Util.is_congruent_number(p) and Util.is_prime(q) and Util.is_congruent_number(q):
            n = p * q
            x = 1
            while Util.coprime(n, x):
                x = randint(0, n)
            return x

    @staticmethod
    def coprime(a, b):
        return gcd(a, b) == 1


class BBS:
    p = 0
    q = 0
    n = 0
    seed = 0
    generatedValues = []

    def __init__(self, p, q):
        if not self.__check_params(p):
            self.p = p
        if not self.__check_params(q):
            self.q = q
        if self.p > 0 and self.q > 0:
            self.n = self.p * self.q
            while not Util.coprime(self.n, self.seed) and self.seed < 1:
                self.seed = randint(0, self.n - 1)

    @staticmethod
    def __check_params(number):
        is_error = False
        if not Util.is_prime(number):
            print(number, 'is not prime')
            is_error = True
        return is_error

    def __generate_value(self):
        if self.p > 0 and self.q > 0:
            x = 0
            while not Util.coprime(self.n, x):
                x = randint(0, self.n)
            return pow(x, 2) % self.n

    def generate_bits(self, amount):
        if self.p == self.q:
            print('p should be diffrent than q')
            return False
        if self.n == 0:
            print('N is equal 0')
            return False
        else:
            bits_array = []
            for i in range(amount + 1):
                generated_value = self.__generate_value()
                self.generatedValues.append(generated_value)
                if generated_value % 2 == 0:
                    bits_array.append(0)
                else:
                    bits_array.append(1)

            return bits_array


class AuthService:

    hashing_algorithm = 'SHA-256'
    message_encoding = 'ascii'
    rsa_bits = 1024

    @staticmethod
    def generate_keys(address):
        if not os.path.exists('keys'):
            os.mkdir('keys')
        (public_key, private_key) = rsa.newkeys(AuthService.rsa_bits)
        with open(f'keys/{address}_public.pem', 'wb') as p:
            p.write(public_key.save_pkcs1('PEM'))
        with open(f'keys/{address}_private.pem', 'wb') as p:
            p.write(private_key.save_pkcs1('PEM'))

    @staticmethod
    def load_key(address, key_type):
        key_path = f'keys/{address}_{key_type}.pem'
        if not os.path.exists(key_path):
            AuthService.generate_keys(address)
        with open(f'keys/{address}_{key_type}.pem', 'rb') as p:
            if key_type == 'public':
                return rsa.PublicKey.load_pkcs1(p.read())
            elif key_type == 'private':
                return rsa.PrivateKey.load_pkcs1(p.read())
            else:
                raise SystemExit('!!> Invalid key type.')

    @staticmethod
    def send(file, dst_address):
        plaintext = AuthService.read_file(file)
        src_address = plaintext.split(';')[0]
        prk_src = AuthService.load_key(src_address, 'private')
        puk_dst = AuthService.load_key(dst_address, 'public')
        print(prk_src)
        # for i in prk_src:
        #     print(i)
        exit(0)

    @staticmethod
    def read_file(filepath, mode='r', encoding='utf8'):
        with open(filepath, mode=mode, encoding=encoding) as input_file:
            return input_file.read()


if __name__ == '__main__':
    '''
    py secAuth.py [ id_file_path ] [ destination_address ]
    py secAuth.py ID_Source.txt 1.1.1.2
    '''
    try:
        id_file_path = sys.argv[1]
        destination_address = sys.argv[2]
    except IndexError:
        raise SystemExit(f">> Usage: python {sys.argv[0]} "
                         f"[ id_file_path ] [ destination_address ]\n")

    AuthService.send(id_file_path, destination_address)

    # # Encryption
    # with open('ID_Source.txt', mode='r', encoding='utf8') as id_file:
    #     cipher_text = Crypto.encrypt(id_file.read(), puk)
    # with open('ID_Source.enc', mode='wb') as id_enc_file:
    #     id_enc_file.write(cipher_text)
    #
    # # Decryption
    # with open('ID_Source.enc', mode='rb') as id_enc_file:
    #     decrypted_text = Crypto.decrypt(id_enc_file.read(), prk)
    # with open('ID_Source.dec', mode='w') as id_dec_file:
    #     id_dec_file.write(decrypted_text)

    # bbs_gen = BBS(p=5, q=3)
    # random_bits = bbs_gen.generate_bits(12)
    # print(random_bits)
    # print(''.join([str(random_bit) for random_bit in random_bits]))
