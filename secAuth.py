import sys
import subprocess
from importlib.util import find_spec

if find_spec('numpy') is None:
    subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'numpy', '--disable-pip-version-check'])
import numpy as np

from random import randint, getrandbits
from math import gcd, sqrt


class Crypto:

    @staticmethod
    def encrypt(input_file_path, ip_key, encrypt_key, output_file_path):

        def encrypt_text_arr():
            encrypted_line = ''
            for sixteen_chars in plaintext_arr:

                # Permute array
                permuted_arr = Crypto.initial_permutation(sixteen_chars, ip_key)

                # Shift right by 8
                shifted_arr = Crypto.shift_right_rotation(permuted_arr, by=8)

                # Split into two nibbles
                left_nibble, right_nibble = Crypto.split_into_nibbles(shifted_arr)

                # XOR nibbles
                left_nibble_xor = Crypto.xor(left_nibble, key_l0)
                right_nibble_xor = Crypto.xor(right_nibble, key_r0)

                # Swap nibbles
                left_nibble = right_nibble_xor
                right_nibble = left_nibble_xor

                # XOR nibbles again
                left_nibble_xor = Crypto.xor(left_nibble, key_l1)
                right_nibble_xor = Crypto.xor(right_nibble, key_r1)

                # Concatenate nibbles
                concat_arr = np.concatenate([left_nibble_xor, right_nibble_xor], axis=None)

                # Inverse permute
                inverse_perm_arr = Crypto.inverse_permutation(concat_arr, ip_key)

                # Decode characters
                decoded_arr = Crypto.decode(inverse_perm_arr)

                # Concatenate array elements
                encrypted_line += ''.join(list(decoded_arr))

            return encrypted_line

        # Read plaintext
        plaintext = Crypto.read_file(filepath=input_file_path)

        # Split plaintext into lines of 16 characters
        plaintext_arr = Crypto.split_by_x(text=plaintext, x=16, dummy_char=' ')

        # Generate XOR keys
        key_l0, key_r0, key_l1, key_r1 = Crypto.generate_keys(encrypt_key)

        # Generate encrypted text
        encrypted_text = encrypt_text_arr()

        Crypto.write_file(output_text=encrypted_text, filepath=output_file_path)
        print(f'ENC> The encrypted text is written into {output_file_path}\n')

    @staticmethod
    def decrypt(input_file_path, ip_key, decrypt_key, output_file_path):

        def decrypt_text_arr():
            decrypted_line = ''
            for sixteen_chars in ciphertext_arr:
                # Permute array
                permuted_arr = Crypto.initial_permutation(sixteen_chars, ip_key)

                # Split into two nibbles
                left_nibble, right_nibble = Crypto.split_into_nibbles(permuted_arr)

                # XOR nibbles
                left_nibble_xor = Crypto.xor(left_nibble, key_l1)
                right_nibble_xor = Crypto.xor(right_nibble, key_r1)

                # Swap nibbles
                left_nibble = right_nibble_xor
                right_nibble = left_nibble_xor

                # XOR nibbles again
                left_nibble_xor = Crypto.xor(left_nibble, key_l0)
                right_nibble_xor = Crypto.xor(right_nibble, key_r0)

                # Concatenate nibbles
                concat_arr = np.concatenate([left_nibble_xor, right_nibble_xor], axis=None)

                # Shift right by 8
                shifted_arr = Crypto.shift_right_rotation(concat_arr, by=8)

                # Inverse permute
                inverse_perm_arr = Crypto.inverse_permutation(shifted_arr, ip_key)

                # Decode characters
                decoded_arr = Crypto.decode(inverse_perm_arr)

                # Concatenate array elements
                decrypted_line += ''.join(list(decoded_arr))

            return decrypted_line.replace('\r\n', '\n').strip()

        # Read ciphertext
        ciphertext = Crypto.read_file(filepath=input_file_path)

        # Split ciphertext into lines of 16 characters
        ciphertext_arr = Crypto.split_by_x(text=ciphertext, x=16)

        # Generate XOR keys
        key_l0, key_r0, key_l1, key_r1 = Crypto.generate_keys(decrypt_key)

        # Generate decrypted text
        decrypted_text = decrypt_text_arr()

        Crypto.write_file(output_text=decrypted_text, filepath=output_file_path)
        print(f'DEC> The decrypted text is written into {output_file_path}\n')

    @staticmethod
    def read_file(filepath):
        try:
            with open(filepath, 'rb') as io_file:
                return io_file.read()
        except FileNotFoundError:
            raise SystemExit(f'!!!> Error: No such file: "{filepath}"')

    @staticmethod
    def write_file(output_text, filepath):
        with open(filepath, 'w', encoding='utf8') as io_file:
            io_file.write(output_text)

    @staticmethod
    def encode(input_arr):
        if input_arr.ndim == 1:
            return np.array([ord(x) for x in input_arr])
        elif input_arr.ndim == 2:
            return np.array([[ord(x) for x in line] for line in input_arr])
        else:
            print('The array isn\'t one or two dimensional')
            exit(0)

    @staticmethod
    def decode(input_arr):
        if input_arr.ndim == 1:
            return np.array([chr(x) for x in input_arr])
        elif input_arr.ndim == 2:
            return np.array([[chr(x) for x in line] for line in input_arr])
        else:
            print('The array isn\'t one or two dimensional')
            exit(0)

    @staticmethod
    def split_by_x(x, text, dummy_char=None):
        text_list = list(text)

        if dummy_char is not None:
            while True:
                if len(text_list) % x == 0:
                    break
                text_list.append(ord(dummy_char))

        text_arr = np.array(text_list, dtype=np.int32)
        return text_arr.reshape(-1, x)

    @staticmethod
    def split_into_nibbles(input_arr):
        return input_arr[:8], input_arr[8:]

    @staticmethod
    def generate_keys(encrypt_key):

        encoded_key = Crypto.encode(np.array(list(encrypt_key)))
        encoded_key_arr = Crypto.split_by_x(text=encoded_key, x=4)

        key_l0 = np.concatenate([encoded_key_arr[:, 1], encoded_key_arr[:, 3]], axis=None)
        key_r0 = np.concatenate([encoded_key_arr[:, 0], encoded_key_arr[:, 2]], axis=None)
        key_l1 = np.concatenate([encoded_key_arr[:, 2], encoded_key_arr[:, 3]], axis=None)
        key_r1 = np.concatenate([encoded_key_arr[:, 0], encoded_key_arr[:, 1]], axis=None)

        return key_l0, key_r0, key_l1, key_r1

    @staticmethod
    def initial_permutation(input_arr, perm_key):
        new_list = [input_arr[ip_index] for ip_index in perm_key]
        return np.array(new_list)

    @staticmethod
    def inverse_permutation(input_arr, perm_key):
        inverse_arr = np.array([None] * len(input_arr))
        for char_index, char in zip(perm_key, input_arr):
            inverse_arr[char_index] = char
        return inverse_arr

    @staticmethod
    def shift_right_rotation(input_arr, by=8):
        return np.roll(input_arr, by)

    @staticmethod
    def xor(arr_one, arr_two):
        result = []
        for x, y in zip(arr_one, arr_two):
            result.append(x ^ y)
        return np.array(result)


class Util:
    @staticmethod
    def printPrimeNumbers(max_val):
        for number in range(2, max_val):
            if Util.isPrime(number):
                print(number)

    @staticmethod
    def printPrimeAndCongruentNumbers(max_val):
        for number in range(2, max_val):
            if Util.isPrime(number) and Util.isCongruentNumber(number):
                print(number)

    @staticmethod
    def isPrime(number):
        if number < 2:
            return False
        elif number == 2 or number == 3:
            return True
        elif number % 2 == 0:
            return False
    
        dx = 4
        for i in range(5, int(sqrt(number)), dx):
            if number % i == 0:
                if number / i == number // i:
                    print(f'{number}/{i} = {number/i}')
                    return False
                else:
                    raise SystemExit('Calculation error.')
            dx -= dx - 6
    
        return True

    @staticmethod
    def isCongruentNumber(number):
        # a - b = k * n
        # b = 3
        # k = 4
        # number - 3 = 4 * n
        if (number - 3) % 4 == 0:
            return True
        else:
            return False

    @staticmethod
    def findX(p, q):
        if Util.isPrime(p) and Util.isCongruentNumber(p) and Util.isPrime(q) and Util.isCongruentNumber(q):
            n = p * q
            x = 1
            while Util.coprime(n, x):
                x = randint(0, n)
            return x

    @staticmethod
    def coprime(a, b):
        return gcd(a, b) == 1


class BBS:
    p = 0
    q = 0
    n = 0
    seed = 0
    generatedValues = []

    def __init__(self, p, q):
        self.setP(p)
        self.setQ(q)
        if self.p > 0 and self.q > 0:
            self.__setN()
            self.__setSeed()

    def setP(self, p):
        if not self.__checkParams(p):
            self.p = p

    def setQ(self, q):
        if not self.__checkParams(q):
            self.q = q

    def __checkParams(self, number):
        is_error = False
        if not Util.isPrime(number):
            print(number, 'is not prime')
            is_error = True

        return is_error

    def __setN(self):
        self.n = self.p * self.q

    def __setSeed(self):
        while not Util.coprime(self.n, self.seed) and self.seed < 1:
            self.seed = randint(0, self.n - 1)

    def __generateValue(self):
        if self.p > 0 and self.q > 0:
            x = 0
            while not Util.coprime(self.n, x):
                x = randint(0, self.n)
            return pow(x, 2) % self.n

    def generateBits(self, amount):
        if self.p == self.q:
            print('p should be diffrent than q')
            return False

        if self.n == 0:
            print('N is equal 0')
            return False

        else:
            bits_array = []
            amount += 1

            for i in range(amount):
                generated_value = self.__generateValue()
                self.generatedValues.append(generated_value)

                if generated_value % 2 == 0:
                    bits_array.append(0)
                else:
                    bits_array.append(1)

            return bits_array


class AuthService:
    pass


if __name__ == '__main__':
    bbs_gen = BBS(p=5, q=3)
    random_bits = bbs_gen.generateBits(12)
    print(random_bits)
    print(''.join([str(random_bit) for random_bit in random_bits]))
