import os
import sys
import subprocess
from importlib.util import find_spec

if find_spec('rsa') is None:
    subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'rsa', '--disable-pip-version-check'])
import rsa

from random import randint
from math import gcd, sqrt


class RSACrypto:
    rsa_bits = 1024

    @staticmethod
    def generate_keys(address):
        if not os.path.exists('keys'):
            os.mkdir('keys')
        (public_key, private_key) = rsa.newkeys(RSACrypto.rsa_bits)

        with open(f'keys/{address}_public.pem', 'wb') as p:
            p.write(public_key.save_pkcs1('PEM'))
        with open(f'keys/{address}_private.pem', 'wb') as p:
            p.write(private_key.save_pkcs1('PEM'))

    @staticmethod
    def load_key(address, key_type):
        key_path = f'keys/{address}_{key_type}.pem'
        if not os.path.exists(key_path):
            RSACrypto.generate_keys(address)
        with open(f'keys/{address}_{key_type}.pem', 'rb') as p:
            if key_type == 'public':
                return rsa.PublicKey.load_pkcs1(p.read())
            elif key_type == 'private':
                return rsa.PrivateKey.load_pkcs1(p.read())
            else:
                raise SystemExit('!!> Invalid key type.')

    @staticmethod
    def encrypt(message, public_key):
        if type(message) is not bytes:
            text = message.encode(AuthService.message_encoding)
        else:
            text = message
        chunk_size = RSACrypto.rsa_bits // 8 - 11
        result = b''
        for i in range(0, len(text), chunk_size):
            result += rsa.encrypt(text[i:i + chunk_size], pub_key=public_key)
        return result

    @staticmethod
    def decrypt(ciphertext, private_key):
        chunk_size = RSACrypto.rsa_bits // 8
        result = ''
        for i in range(0, len(ciphertext), chunk_size):
            result += rsa.decrypt(ciphertext[i:i + chunk_size], private_key).decode(AuthService.message_encoding)
        return result

    @staticmethod
    def sign(message, private_key):
        if type(message) is not bytes:
            return rsa.sign(message.encode(AuthService.message_encoding), private_key, AuthService.hashing_algorithm)
        return rsa.sign(message, private_key, AuthService.hashing_algorithm)

    @staticmethod
    def verify(message, signature, public_key):
        if type(message) is not bytes:
            return rsa.verify(
                message.encode(AuthService.message_encoding), signature, public_key, ) == AuthService.hashing_algorithm
        return rsa.verify(message, signature, public_key, ) == AuthService.hashing_algorithm


class Util:
    @staticmethod
    def print_prime_numbers(max_val):
        for number in range(2, max_val):
            if Util.is_prime(number):
                print(number)

    @staticmethod
    def print_prime_and_congruent_numbers(max_val):
        for number in range(2, max_val):
            if Util.is_prime(number) and Util.is_congruent_number(number):
                print(number)

    @staticmethod
    def is_prime(number):
        if number < 2:
            return False
        elif number == 2 or number == 3:
            return True
        elif number % 2 == 0:
            return False

        dx = 4
        for i in range(5, int(sqrt(number)), dx):
            if number % i == 0:
                if number / i == number // i:
                    print(f'{number}/{i} = {number / i}')
                    return False
                else:
                    raise SystemExit('Calculation error.')
            dx -= dx - 6

        return True

    @staticmethod
    def is_congruent_number(number):
        # a - b = k * n
        # b = 3
        # k = 4
        # number - 3 = 4 * n
        if (number - 3) % 4 == 0:
            return True
        else:
            return False

    @staticmethod
    def find_x(p, q):
        if Util.is_prime(p) and Util.is_congruent_number(p) and Util.is_prime(q) and Util.is_congruent_number(q):
            n = p * q
            x = 1
            while Util.coprime(n, x):
                x = randint(0, n)
            return x

    @staticmethod
    def coprime(a, b):
        return gcd(a, b) == 1


class BBS:
    p = 0
    q = 0
    n = 0
    seed = 0
    generatedValues = []

    def __init__(self, p, q):
        if not self.__check_params(p):
            self.p = p
        if not self.__check_params(q):
            self.q = q
        if self.p > 0 and self.q > 0:
            self.n = self.p * self.q
            while not Util.coprime(self.n, self.seed) and self.seed < 1:
                self.seed = randint(0, self.n - 1)

    @staticmethod
    def __check_params(number):
        is_error = False
        if not Util.is_prime(number):
            print(number, 'is not prime')
            is_error = True
        return is_error

    def __generate_value(self):
        if self.p > 0 and self.q > 0:
            x = 0
            while not Util.coprime(self.n, x):
                x = randint(0, self.n)
            return pow(x, 2) % self.n

    def generate_bits(self, amount, return_type='bytes'):
        if self.p == self.q:
            print('p should be different than q')
            return False
        if self.n == 0:
            print('N is equal 0')
            return False
        else:
            bits_array = []
            for i in range(amount + 1):
                generated_value = self.__generate_value()
                self.generatedValues.append(generated_value)
                if generated_value % 2 == 0:
                    bits_array.append(0)
                else:
                    bits_array.append(1)
            if return_type == 'list':
                return bits_array
            elif return_type == 'bytes':
                return ''.join([str(random_bit) for random_bit in bits_array]).encode(AuthService.message_encoding)
            else:
                return False


class AuthService:
    hashing_algorithm = 'SHA-256'
    message_encoding = 'ascii'
    bbs_keygen = BBS(p=11, q=19)

    @staticmethod
    def send(filepath, src_address, dst_address):
        # Read ID message file
        message = AuthService.read_file(filepath)
        print('S> ID Message:\n\t', message)

        assert src_address == message.split(';')[0]

        src_private_key = RSACrypto.load_key(src_address, 'private')
        dst_public_key = RSACrypto.load_key(dst_address, 'public')

        # Hash the message with SHA-256 algorithm
        signed_msg = RSACrypto.sign(message, private_key=src_private_key)
        print('S> Hashed (Signed) Message:\n\t', signed_msg)

        # Concatenate the hashed message with the plaintext
        concat_block = (message + '||').encode(AuthService.message_encoding) + signed_msg
        print('S> Concatenated Block:\n\t', concat_block)

        # Generate session key with the Blum Blum Shub algorithm
        # session_key = AuthService.bbs_keygen.generate_bits(116)
        session_key = AuthService.bbs_keygen.generate_bits(len(concat_block))
        print('S> Session Key:\n\t', session_key)

        # Encrypt concatenated block using the session key
        # concat_block_enc = bytes(a ^ b for a, b in zip(concat_block, session_key))
        concat_block_enc = bytes(a ^ b for a, b in zip(concat_block, session_key))
        print('S> Concatenated Block Encrypted:\n\t', concat_block_enc)

        # Encrypt session key using the destination public key
        session_key_enc = RSACrypto.encrypt(session_key, public_key=dst_public_key)
        print('S> Session Key Encrypted:\n\t', session_key_enc)

        # Concatenate the encrypted session key with the concatenated block
        msg_block_enc = concat_block_enc + b'||' + session_key_enc
        print('S> Encrypted ID Block:\n\t', msg_block_enc)

        # Send (Write) encrypted message to destination
        AuthService.write_file(text=msg_block_enc,
                               filepath='enc_' + filepath,
                               mode='wb')
        print(f'S> Encrypted ID message has sent to {destination_address}')

    @staticmethod
    def receive(filepath, src_address, dst_address):
        # Read received encrypted message file
        print(f'D> Encrypted ID message has received from {src_address}')
        msg_block_enc = AuthService.read_file(filepath, mode='rb')
        print('D> Encrypted ID Block:\n\t', msg_block_enc)

        dst_private_key = RSACrypto.load_key(dst_address, 'private')
        src_public_key = RSACrypto.load_key(src_address, 'public')

        # Split the concatenated [ID||Signature] block from encrypted session key
        assert isinstance(msg_block_enc, bytes)
        concat_block_enc, session_key_enc = msg_block_enc.split(b'||')

        # Decrypt encrypted session key using the destination private key
        session_key = RSACrypto.decrypt(session_key_enc,
                                        private_key=dst_private_key).encode(AuthService.message_encoding)
        print('D> Session Key Decrypted:\n\t', session_key)

        # Decrypt encrypted concatenated block using the session key
        concat_block = bytes(a ^ b for a, b in zip(concat_block_enc, session_key))
        print('D> Concatenated Block Decrypted:\n\t', concat_block)

        # Split concatenated ID and signature
        message, signed_msg = concat_block.split(b'||')
        print('D> Message:\n\t', message)
        print('D> Signed Message:\n\t', signed_msg)

        # Verify the message using the source public key
        verified = RSACrypto.verify(message, signed_msg, public_key=src_public_key)
        print('D> Verification Result:\n\t', verified)

    @staticmethod
    def read_file(filepath, mode='r', encoding=message_encoding):
        if 'b' in mode:
            with open(filepath, mode=mode) as input_file:
                return input_file.read()
        with open(filepath, mode=mode, encoding=encoding) as input_file:
            return input_file.read()

    @staticmethod
    def write_file(text, filepath, mode='w', encoding=message_encoding):
        if 'b' in mode:
            with open(filepath, mode=mode) as output_file:
                output_file.write(text)
        else:
            with open(filepath, mode=mode, encoding=encoding) as output_file:
                output_file.write(text)


if __name__ == '__main__':
    '''
    py secAuth.py [ id_file_path ] [ source_address ] [ destination_address ]
    py secAuth.py ID_Source.txt 1.1.1.1 1.1.1.2
    '''
    try:
        id_file_path = sys.argv[1]
        source_address = sys.argv[2]
        destination_address = sys.argv[3]
    except IndexError:
        raise SystemExit(f">> Usage: python {sys.argv[0]} "
                         f"[ id_file_path ] [ destination_address ]\n")

    print('>> [ Source ]')
    AuthService.send(id_file_path, source_address, destination_address)

    print('\n>> [ Destination ]')
    AuthService.receive('enc_' + id_file_path, source_address, destination_address)
